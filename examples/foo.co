type Thing {
  x, y, z u32 = 3, 4, 5
  pretty bool
  ref &int
  // fptr fun(int)int
}

// fun refs() {
//   // let v = 3 ; let r = mut&v // error: mut ref to immut binding
//   // var v = 3 ; let r mut&int = &v // error: incompatible types, mut&int and &int
//   var v = 3 ; let r mut&int = mut&v ; let p &int = &v // ok, ok
//   // let rr = &r // error: referencing reference type mut&int
//   // let v2 = *r // ok
//   // *p = 4 // error: cannot assign via immutable reference of type &int
//   *r = 4
// }

// fun Thing.refs(mut this) {
//   var v = 3
//   .ref = &v
// }

fun Thing.foo(this, x int) int { int(.x) * x }
fun Thing.bar(this) u32 { .x * .y }
fun Thing.set_x(mut this, x u32) u32 { .x = x }

fun bar(x, y int) int {
  let a = Thing(u32(x), pretty: true, y: 5)
  //a.fptr(x)
  a.set_x(9)
  int(a.x) + a.foo(x) * y
}

fun foo(x, y int) int {
  var z = x + y * int(2)
  bar(z, y: 6)
}

// fun negative_num() void {
//   let _ = -0x8000000000000000
//   let _ = -1.23
// }
